From 6dd24af0a881aa7440f127036f42d8f521628c24 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Sun, 5 Oct 2014 16:27:00 -0400
Subject: [PATCH] gdm: disallow cancel after verification succeeds

Once verification has succeeded, the train's already
left the building and we shouldn't allow canceling.

This commit renders the cancel button non-reactive
and makes the cancel function be a noop after
verification succeeds.
---
 js/gdm/authPrompt.js | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/js/gdm/authPrompt.js b/js/gdm/authPrompt.js
index fd02c4d..d82b2b2 100644
--- a/js/gdm/authPrompt.js
+++ b/js/gdm/authPrompt.js
@@ -232,60 +232,61 @@ const AuthPrompt = new Lang.Class({
         // a smartcard. Smartcard insertion "preempts" what the user was
         // doing, and smartcard removal aborts the preemption.
         // The exceptions are: 1) Don't reset on smartcard insertion if we're already verifying
         //                        with a smartcard
         //                     2) Don't reset if we've already succeeded at verification and
         //                        the user is getting logged in.
         if (this._userVerifier.serviceIsDefault(GdmUtil.SMARTCARD_SERVICE_NAME) &&
             this.verificationStatus == AuthPromptStatus.VERIFYING &&
             this.smartcardDetected)
             return;
 
         if (this.verificationStatus != AuthPromptStatus.VERIFICATION_SUCCEEDED)
             this.reset();
     },
 
     _onShowMessage: function(userVerifier, message, type) {
         this.setMessage(message, type);
         this.emit('prompted');
     },
 
     _onVerificationFailed: function() {
         this.clear();
 
         this.updateSensitivity(true);
         this.setActorInDefaultButtonWell(null);
         this.verificationStatus = AuthPromptStatus.VERIFICATION_FAILED;
     },
 
     _onVerificationComplete: function() {
         this.verificationStatus = AuthPromptStatus.VERIFICATION_SUCCEEDED;
+	this.cancelButton.reactive = false;
     },
 
     _onReset: function() {
         if (this.verificationStatus != AuthPromptStatus.VERIFICATION_SUCCEEDED) {
             this.verificationStatus = AuthPromptStatus.NOT_VERIFYING;
             this.reset();
         }
     },
 
     addActorToDefaultButtonWell: function(actor) {
         this._defaultButtonWell.add_child(actor);
     },
 
     setActorInDefaultButtonWell: function(actor, animate) {
         if (!this._defaultButtonWellActor &&
             !actor)
             return;
 
         let oldActor = this._defaultButtonWellActor;
 
         if (oldActor)
             Tweener.removeTweens(oldActor);
 
         let isSpinner;
         if (actor == this._spinner.actor)
             isSpinner = true;
         else
             isSpinner = false;
 
         if (this._defaultButtonWellActor != actor && oldActor) {
@@ -403,60 +404,61 @@ const AuthPrompt = new Lang.Class({
 
     updateSensitivity: function(sensitive) {
         this._updateNextButtonSensitivity(sensitive);
         this._entry.reactive = sensitive;
         this._entry.clutter_text.editable = sensitive;
     },
 
     hide: function() {
         this.setActorInDefaultButtonWell(null, true);
         this.actor.hide();
         this._message.opacity = 0;
 
         this.setUser(null);
 
         this.updateSensitivity(true);
         this._entry.set_text('');
     },
 
     setUser: function(user) {
         if (user) {
             let userWidget = new UserWidget.UserWidget(user);
             this._userWell.set_child(userWidget.actor);
         } else {
             this._userWell.set_child(null);
         }
     },
 
     reset: function() {
         let oldStatus = this.verificationStatus;
         this.verificationStatus = AuthPromptStatus.NOT_VERIFYING;
+	this.cancelButton.reactive = true;
 
         if (oldStatus == AuthPromptStatus.VERIFYING)
             this._userVerifier.cancel();
 
         this._queryingService = null;
         this.clear();
         this._message.opacity = 0;
         this.setUser(null);
         this.stopSpinning();
 
         if (oldStatus == AuthPromptStatus.VERIFICATION_FAILED)
             this.emit('failed');
 
         let beginRequestType;
 
         if (this._mode == AuthPromptMode.UNLOCK_ONLY) {
             // The user is constant at the unlock screen, so it will immediately
             // respond to the request with the username
             beginRequestType = BeginRequestType.PROVIDE_USERNAME;
         } else if (this._userVerifier.serviceIsForeground(GdmUtil.OVIRT_SERVICE_NAME) ||
                    this._userVerifier.serviceIsForeground(GdmUtil.SMARTCARD_SERVICE_NAME)) {
             // We don't need to know the username if the user preempted the login screen
             // with a smartcard or with preauthenticated oVirt credentials
             beginRequestType = BeginRequestType.DONT_PROVIDE_USERNAME;
         } else {
             // In all other cases, we should get the username up front.
             beginRequestType = BeginRequestType.PROVIDE_USERNAME;
         }
 
         this.emit('reset', beginRequestType);
@@ -472,35 +474,38 @@ const AuthPrompt = new Lang.Class({
     },
 
     begin: function(params) {
         params = Params.parse(params, { userName: null,
                                         hold: null });
 
         this.updateSensitivity(false);
 
         let hold = params.hold;
         if (!hold)
             hold = new Batch.Hold();
 
         this._userVerifier.begin(params.userName, hold);
         this.verificationStatus = AuthPromptStatus.VERIFYING;
     },
 
     finish: function(onComplete) {
         if (!this._userVerifier.hasPendingMessages) {
             onComplete();
             return;
         }
 
         let signalId = this._userVerifier.connect('no-more-messages',
                                                   Lang.bind(this, function() {
                                                       this._userVerifier.disconnect(signalId);
                                                       onComplete();
                                                   }));
     },
 
     cancel: function() {
+        if (this.verificationStatus == AuthPromptStatus.NOT_VERIFYING || this.verificationStatus == AuthPromptStatus.VERIFICATION_SUCCEEDED) {
+            return;
+        }
         this.reset();
         this.emit('cancelled');
     }
 });
 Signals.addSignalMethods(AuthPrompt.prototype);
-- 
2.1.0

