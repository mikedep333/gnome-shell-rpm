From f936c6e5e2566e6a665b61b1610c249e7ec5479b Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Mon, 6 Oct 2014 16:38:03 -0400
Subject: [PATCH 1/2] screenShield: focus login screen after lifting shield

This commit ensures the login screen gets focused after
the screen shield is raised.

The code affects the unlock screen as well, but it's
less important since the unlock screen gets destroyed
and recreated each time the curtain moves, so it
has an opportunity to take focus on its own.
---
 js/ui/screenShield.js | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/js/ui/screenShield.js b/js/ui/screenShield.js
index 089333b..4473b72 100644
--- a/js/ui/screenShield.js
+++ b/js/ui/screenShield.js
@@ -1,37 +1,38 @@
 // -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 
 const Cairo = imports.cairo;
 const Clutter = imports.gi.Clutter;
 const Gio = imports.gi.Gio;
 const GLib = imports.gi.GLib;
 const GnomeDesktop = imports.gi.GnomeDesktop;
+const Gtk = imports.gi.Gtk;
 const Lang = imports.lang;
 const Mainloop = imports.mainloop;
 const Meta = imports.gi.Meta;
 const Shell = imports.gi.Shell;
 const Signals = imports.signals;
 const St = imports.gi.St;
 const TweenerEquations = imports.tweener.equations;
 
 const Background = imports.ui.background;
 const GnomeSession = imports.misc.gnomeSession;
 const Hash = imports.misc.hash;
 const Layout = imports.ui.layout;
 const OVirt = imports.gdm.oVirt;
 const LoginManager = imports.misc.loginManager;
 const Lightbox = imports.ui.lightbox;
 const Main = imports.ui.main;
 const Overview = imports.ui.overview;
 const MessageTray = imports.ui.messageTray;
 const ShellDBus = imports.ui.shellDBus;
 const SmartcardManager = imports.misc.smartcardManager;
 const Tweener = imports.ui.tweener;
 const Util = imports.misc.util;
 
 const SCREENSAVER_SCHEMA = 'org.gnome.desktop.screensaver';
 const LOCK_ENABLED_KEY = 'lock-enabled';
 const LOCK_DELAY_KEY = 'lock-delay';
 
 // fraction of screen height the arrow must reach before completing
 // the slide up automatically
 const ARROW_DRAG_THRESHOLD = 0.1;
@@ -851,60 +852,63 @@ const ScreenShield = new Lang.Class({
     _onLightboxShown: function() {
         this.activate(false);
     },
 
     showDialog: function() {
         // Ensure that the stage window is mapped, before taking a grab
         // otherwise X errors out
         Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
             if (!this._becomeModal()) {
                 // In the login screen, this is a hard error. Fail-whale
                 log('Could not acquire modal grab for the login screen. Aborting login process.');
                 Meta.quit(Meta.ExitCode.ERROR);
             }
 
             return false;
         }));
 
         this.actor.show();
         this._isGreeter = Main.sessionMode.isGreeter;
         this._isLocked = true;
         this._ensureUnlockDialog(true, true);
         this._hideLockScreen(false, 0);
     },
 
     _hideLockScreenComplete: function() {
         if (Main.sessionMode.currentMode == 'lock-screen')
             Main.sessionMode.popMode('lock-screen');
 
         this._lockScreenState = MessageTray.State.HIDDEN;
         this._lockScreenGroup.hide();
+
+        this._dialog.actor.grab_key_focus();
+        this._dialog.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
     },
 
     _hideLockScreen: function(animate, velocity) {
         if (this._lockScreenState == MessageTray.State.HIDDEN)
             return;
 
         this._lockScreenState = MessageTray.State.HIDING;
 
         Tweener.removeTweens(this._lockScreenGroup);
 
         if (animate) {
             // Tween the lock screen out of screen
             // if velocity is not specified (i.e. we come here from pressing ESC),
             // use the same speed regardless of original position
             // if velocity is specified, it's in pixels per milliseconds
             let h = global.stage.height;
             let delta = (h + this._lockScreenGroup.y);
             let min_velocity = global.stage.height / (CURTAIN_SLIDE_TIME * 1000);
 
             velocity = Math.max(min_velocity, velocity);
             let time = (delta / velocity) / 1000;
 
             Tweener.addTween(this._lockScreenGroup,
                              { y: -h,
                                time: time,
                                transition: 'easeInQuad',
                                onComplete: Lang.bind(this, this._hideLockScreenComplete),
                              });
         } else {
             this._hideLockScreenComplete();
-- 
2.1.0


From e5c2ad5e29ae1dd691f1762ff1a5e94f0dff8eb5 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 8 Oct 2014 09:39:44 -0400
Subject: [PATCH 2/2] screenShield: fix trace back when unlocking session from
 another vt

commit 1d374ac8bd496f6fa6f4c55ffd207bd30bd50075 introduced a bug that
prevents unlock from working when initiated from another VT
(user switching).

This commit fixes the exception raised.

https://bugzilla.gnome.org/show_bug.cgi?id=708105
---
 js/ui/screenShield.js | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/js/ui/screenShield.js b/js/ui/screenShield.js
index 4473b72..033ed2c 100644
--- a/js/ui/screenShield.js
+++ b/js/ui/screenShield.js
@@ -853,62 +853,64 @@ const ScreenShield = new Lang.Class({
         this.activate(false);
     },
 
     showDialog: function() {
         // Ensure that the stage window is mapped, before taking a grab
         // otherwise X errors out
         Meta.later_add(Meta.LaterType.BEFORE_REDRAW, Lang.bind(this, function() {
             if (!this._becomeModal()) {
                 // In the login screen, this is a hard error. Fail-whale
                 log('Could not acquire modal grab for the login screen. Aborting login process.');
                 Meta.quit(Meta.ExitCode.ERROR);
             }
 
             return false;
         }));
 
         this.actor.show();
         this._isGreeter = Main.sessionMode.isGreeter;
         this._isLocked = true;
         this._ensureUnlockDialog(true, true);
         this._hideLockScreen(false, 0);
     },
 
     _hideLockScreenComplete: function() {
         if (Main.sessionMode.currentMode == 'lock-screen')
             Main.sessionMode.popMode('lock-screen');
 
         this._lockScreenState = MessageTray.State.HIDDEN;
         this._lockScreenGroup.hide();
 
-        this._dialog.actor.grab_key_focus();
-        this._dialog.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
+        if (this._dialog) {
+            this._dialog.actor.grab_key_focus();
+            this._dialog.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
+        }
     },
 
     _hideLockScreen: function(animate, velocity) {
         if (this._lockScreenState == MessageTray.State.HIDDEN)
             return;
 
         this._lockScreenState = MessageTray.State.HIDING;
 
         Tweener.removeTweens(this._lockScreenGroup);
 
         if (animate) {
             // Tween the lock screen out of screen
             // if velocity is not specified (i.e. we come here from pressing ESC),
             // use the same speed regardless of original position
             // if velocity is specified, it's in pixels per milliseconds
             let h = global.stage.height;
             let delta = (h + this._lockScreenGroup.y);
             let min_velocity = global.stage.height / (CURTAIN_SLIDE_TIME * 1000);
 
             velocity = Math.max(min_velocity, velocity);
             let time = (delta / velocity) / 1000;
 
             Tweener.addTween(this._lockScreenGroup,
                              { y: -h,
                                time: time,
                                transition: 'easeInQuad',
                                onComplete: Lang.bind(this, this._hideLockScreenComplete),
                              });
         } else {
             this._hideLockScreenComplete();
-- 
2.1.0

